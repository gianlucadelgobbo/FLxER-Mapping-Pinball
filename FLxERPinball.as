package{	import Box2D.Collision.Shapes.b2CircleShape;	import Box2D.Collision.Shapes.b2PolygonShape;	import Box2D.Collision.Shapes.b2Shape;	import Box2D.Common.Math.b2Vec2;	import Box2D.Dynamics.Joints.b2MouseJoint;	import Box2D.Dynamics.Joints.b2MouseJointDef;	import Box2D.Dynamics.Joints.b2RevoluteJoint;	import Box2D.Dynamics.Joints.b2RevoluteJointDef;	import Box2D.Dynamics.b2Body;	import Box2D.Dynamics.b2BodyDef;	import Box2D.Dynamics.b2DebugDraw;	import Box2D.Dynamics.b2Fixture;	import Box2D.Dynamics.b2FixtureDef;	import Box2D.Dynamics.b2World;	import Box2DSeparator.*;		import flash.display.Sprite;	import flash.display.StageAlign;    import flash.display.StageScaleMode;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.geom.ColorTransform;	import flash.xml.XMLDocument;	import flash.xml.XMLNode;	import flash.net.*;	import flash.display.Loader;	import flash.filesystem.File;	import flash.net.FileFilter	import flash.system.Security;	import flash.utils.Timer;	import flash.events.TimerEvent;		//[SWF(width="1024", height="768", frameRate="60", backgroundColor="0x000000")]	public class FLxERPinball extends Sprite {				public static const GRAVITY:int  = 3;				private var _screenWidth:int;		private var _screenHeight:int;		private var _ballRadius:int = 6;		private var bordersfile:String = "/SVGmaps/FLxERPinball_maps/borders.svg"		private var mapfile:String = "/SVGmaps/FLxERPinball_maps/map.svg"				private var _world:b2World;		private var _ball:b2Body;		private var _b2Vec0:b2Vec2 = new b2Vec2(0,0);		private var _gravityDown:b2Vec2 = new b2Vec2(0,GRAVITY);		private var _genericVec2:b2Vec2;		private var _ballSpeedY:Number = 0.1;						private var _container:Sprite;		private var _debugContainer:Sprite;				private var _controls:Vector.<Control>;				private var myLoader:URLLoader;							private var sep:b2Separator;		private var bodyDef:b2BodyDef;		private var ballStartPosition:Array;		private var _ballFixture:b2FixtureDef;		private var _mapFixture:b2FixtureDef;				private var myTimer:Timer;		private var rightstatus:uint = 0;		private var leftstatus:uint = 0;		private var enterstatus:uint = 0;		private var debugMode:Boolean = true;				private var leftControl:Control;		private var rightControl:Control;		private var leftControlSprite:ControlSprite;		private var rightControlSprite:ControlSprite;				private var ballSprite:Sprite		private var restitutionMap:Number = 1; //0 2		private var restitutionCircle:Number = 0.5; //0 2		private var restitutionControl:Number = 0.8;				private var myRedOffset:Number		private var myGreenOffset:Number		private var myBlueOffset:Number		private var myBallRedOffset:Number		private var myBallGreenOffset:Number		private var myBallBlueOffset:Number				private var auto:Boolean = true;		public function FLxERPinball() {			/*			*/			var flxerFolder:File = File.documentsDirectory;			flxerFolder = flxerFolder.resolvePath("FLxER-Folder");			bordersfile = "file://"+flxerFolder.nativePath+bordersfile;			mapfile = "file://"+flxerFolder.nativePath+mapfile;			//stage.scaleMode = StageScaleMode.NO_SCALE;			//stage.align = StageAlign.TOP_LEFT;			_world = new b2World(_b2Vec0,true);			//_world = new b2World(new b2Vec2(0,0),true);						_container = new Sprite();			addChild(_container);			//_container.x = 5;						_debugContainer = new Sprite();			_container.addChild(_debugContainer);						var debugDraw:b2DebugDraw = new b2DebugDraw();			debugDraw.SetSprite(_debugContainer);			debugDraw.SetDrawScale(Box2DUtils.P2M);			debugDraw.SetFlags(b2DebugDraw.e_shapeBit);			debugDraw.SetFillAlpha(0.5);			_world.SetDebugDraw(debugDraw);			addEventListener(Event.ADDED_TO_STAGE, init);		}		private function init(event:Event):void {			_screenWidth = this.stage.stageWidth;			_screenHeight = this.stage.stageHeight;			trace("mapping Pinball _screenWidth: "+_screenWidth);			trace("mapping Pinball _screenHeight: "+_screenHeight);						this.stage.addEventListener(KeyboardEvent.KEY_DOWN, myOnKeyDown, false, 0, true);			this.stage.addEventListener(KeyboardEvent.KEY_UP, myOnKeyUp, false, 0, true);								myLoader = new URLLoader(new URLRequest(mapfile));			myLoader.addEventListener("complete", LoadMapResult);			myLoader.addEventListener("ioError", LoadMapResultError);		}		public function LoadMapResultError(event:Event):void {			trace("LoadMapResultError\n");			trace(event);		}		public function LoadMapResult(event:Event):void {			if (event.type == "complete") {				var xmlMap:XMLDocument = new XMLDocument();				xmlMap.ignoreWhite = true;				xmlMap.parseXML(myLoader.data);				svgDrawer(xmlMap.childNodes[0].childNodes[0]);				myLoader = new URLLoader(new URLRequest(bordersfile));				myLoader.addEventListener("complete", LoadBordersResult);				myLoader.addEventListener("ioError", LoadBordersResultError);			}		}		public function LoadBordersResultError(event:Event):void {			trace("LoadBordersResultError\n");			trace(event);		}		public function LoadBordersResult(event:Event):void {			if (event.type == "complete") {				var xmlMap:XMLDocument = new XMLDocument();				xmlMap.ignoreWhite = true;				xmlMap.parseXML(myLoader.data);				svgBordersDrawer(xmlMap.childNodes[0].childNodes[0]);			}		}		private function svgDrawer(xmlMap:XMLNode):void {			sep = new b2Separator();			for (var a=0;a<xmlMap.childNodes.length;a++) {				switch (xmlMap.childNodes[a].nodeName){					case "g" :						svgBordersDrawer(xmlMap.childNodes[a]);					break;					case "path" :						// 4) And what is of most importance - we need a Vector of b2Vec2 instances so that we can pass the vertices! 						// Remember, we need the vertices in clockwise order! For more information, read the documentation for the b2Separator.Separate() method.						//vec.push(new b2Vec2(-100/30, -100/30), new b2Vec2(100/30, -100/30), new b2Vec2(100/30, 0), new b2Vec2(0, 0), new b2Vec2(-100/30, 100/30));						var vec:Vector.<b2Vec2> = new Vector.<b2Vec2>();						var forma = xmlMap.childNodes[a].attributes.d.substring(1).split("Q");						for (var b=0;b<forma.length;b++) {							forma[b] = forma[b].split(",");							//trace(forma[b][0]+" "+forma[b][1])							trace("SVG_FREE_SHAPE ");							vec.push(new b2Vec2(forma[b][0]/30,forma[b][1]/30));							//wall.graphics.curveTo(forma[b][0],forma[b][1],(forma[b][2] ? forma[b][2] : forma[b][0]),(forma[b][3] ? forma[b][3] : forma[b][1]));						}												// If you want to be sure that the vertices are entered correctly, use the b2Separator.Validate() method!						// Refer to the documentation of b2Separate.Validate() to see what it does and the values it returns.						if(sep.Validate(vec)==0) {							trace("Yey! Those vertices are good to go!");						} else {							trace("Oh, I guess you messed something up :(");						}												// 5) And finally, we pass the b2Body, b2FixtureDef and Vector.<b2Vec2> instances as parameters to the Separate() method!						// It separates the non-convex shape into convex shapes, creates the fixtures and adds them to the body for us! Sweet, eh?						_mapFixture = new b2FixtureDef();						_mapFixture.restitution = restitutionMap;						//_mapFixture.friction = 0.2;						//_mapFixture.density = 1;						sep.Separate(_world, _screenWidth * 0.5, _screenHeight * 0.5, _mapFixture, vec);					break;				}			}		}		private function svgBordersDrawer(xmlMap:XMLNode):void {			for (var a=0;a<xmlMap.childNodes.length;a++) {				switch (xmlMap.childNodes[a].nodeName){					case "g" :						svgDrawer(xmlMap.childNodes[a]);					break;					case "path" :						var vec:Vector.<b2Vec2> = new Vector.<b2Vec2>();						_controls = new Vector.<Control>();						var forma = xmlMap.childNodes[a].attributes.d.substring(1).split("Q");						var stocazzo = 1;						for (var b=0;b<forma.length-1;b++) {							var bstart = forma[b].split(",");							var bend = forma[b+1].split(",");							Box2DUtils.createEdge(_world, (_screenWidth/2)+(bstart[0]/stocazzo), (_screenHeight/2)+(bstart[1]/stocazzo), (_screenWidth/2)+(bend[0]/stocazzo), (_screenHeight/2)+(bend[1]/stocazzo));							//trace(forma[b][0]+" "+forma[b][1])							trace("SVG_BORDERS_SHAPE ");							if (b==1) {								var controlLeft = bstart;							}							if (b==forma.length-2) {								var controlRight = bstart;							}							if (b==forma.length-3) {								ballStartPosition = bstart;							}						}						var d = ((controlRight[0]/stocazzo)-(controlLeft[0]/stocazzo))*.36;						_ballRadius = d/8;						leftControl = new Control(_world, (_screenWidth/2)+(controlLeft[0]/stocazzo), (_screenHeight/2)+(controlLeft[1]/stocazzo), d, Control.TYPE_MAIN_BOTTOM_LEFT, restitutionControl)						_controls.push(leftControl);						rightControl = new Control(_world, (_screenWidth/2)+(controlRight[0]/stocazzo), (_screenHeight/2)+(controlRight[1]/stocazzo), d, Control.TYPE_MAIN_BOTTOM_RIGHT, restitutionControl)						_controls.push(rightControl);												leftControlSprite = new ControlSprite((_screenWidth/2)+(controlLeft[0]/stocazzo), (_screenHeight/2)+(controlLeft[1]/stocazzo), d, Control.TYPE_MAIN_BOTTOM_LEFT);						rightControlSprite = new ControlSprite((_screenWidth/2)+(controlRight[0]/stocazzo), (_screenHeight/2)+(controlRight[1]/stocazzo), d, Control.TYPE_MAIN_BOTTOM_RIGHT);						_container.addChild(leftControlSprite);						_container.addChild(rightControlSprite);						ballSprite = new Sprite();						ballSprite.graphics.beginFill(0x000000);						ballSprite.graphics.drawCircle(0, 0, _ballRadius);						ballSprite.graphics.endFill();						_container.addChild(ballSprite);						myTimer = new Timer(28);						myTimer.start(); 						myTimer.addEventListener(TimerEvent.TIMER, updateWorld);						//create ball						bodyDef = new b2BodyDef();						bodyDef.type = b2Body.b2_dynamicBody;						//bodyDef.position.Set(ballStartPosition[0]-(_ballRadius*3), ballStartPosition[1]-(_ballRadius*3));						bodyDef.position.Set(((_screenWidth/2)+(ballStartPosition[0]/stocazzo)-(_ballRadius*3)), ((_screenHeight/2)+(ballStartPosition[1]/stocazzo)-(_ballRadius*3)));						bodyDef.allowSleep = false;						bodyDef.userData = {name:"ball"};												var circle:b2CircleShape = new b2CircleShape(_ballRadius/Box2DUtils.P2M);						_ballFixture = new b2FixtureDef();						_ballFixture.shape = circle;						_ballFixture.density = .2;						_ballFixture.restitution = restitutionCircle;													//svg = _world.CreateBody(bodyDef);												_ball = _world.CreateBody(bodyDef);						_ball.CreateFixture(_ballFixture);						_ball.SetLinearVelocity(Box2DUtils.P2MVector(0,10000));						_ball.ApplyForce(_gravityDown, _ball.GetPosition());						//_svg = new Vector.<svgPathDrawerB2D>;						//_side_flipper_y						//_blocks = new Vector.<Block>;						//_blocks.push( new Block (_world, ((_screenWidth/2)+(ballStartPosition[0]/stocazzo)-(_ballRadius*3)), ((_screenHeight/2)+(ballStartPosition[1]/stocazzo)-(_ballRadius*3)),null , Block.TYPE_TRIANGLE_BOTTOM));						/*						_blocks.push(new Block (_world, _screenWidth * 0.5, _screenHeight * 0.7, Block.TYPE_SQUARE));						_blocks.push(new Block (_world, _screenWidth * 0.8, _screenHeight * 0.8, Block.TYPE_CIRCLE));						_blocks.push(new Block (_world, _screenWidth * 0.2, _screenHeight * 0.2, Block.TYPE_TRIANGLE_TOP));						_blocks.push(new Block (_world, _screenWidth * 0.5, _screenHeight * 0.3, Block.TYPE_SQUARE));						_blocks.push(new Block (_world, _screenWidth * 0.8, _screenHeight * 0.4, Block.TYPE_CIRCLE));						*/												//_blocks.push( new Block (_world, _screenWidth * 0.2, _screenHeight * 0.6, Block.TYPE_CIRCLE));						//_blocks.push(new Block (_world, _screenWidth * 0.5, _screenHeight * 0.7, Block.TYPE_CIRCLE));						//_blocks.push(new Block (_world, _screenWidth * 0.8, _screenHeight * 0.8, Block.TYPE_CIRCLE));						//_blocks.push(new Block (_world, _screenWidth * 0.2, _screenHeight * 0.2, Block.TYPE_CIRCLE));						//_blocks.push(new Block (_world, _screenWidth * 0.5, _screenHeight * 0.3, Block.TYPE_CIRCLE));						//_blocks.push(new Block (_world, _screenWidth * 0.8, _screenHeight * 0.4, Block.TYPE_CIRCLE));												//createEdges();						//create controllers					break;				}			}		}		private var _cnt:int = 0;		protected function updateWorld(event:Event):void {			if (_ball) {								var by:Number = _ball.GetPosition().y * Box2DUtils.P2M;							/*				if (by <  _screenHeight * 0.5 && _gravityIs == "down") {					_gravityIs = "up";					_ball.ApplyForce(_gravityUp, _ball.GetPosition());				} else if (by > _screenHeight * 0.5 && _gravityIs == "up") {					_gravityIs = "down";					_ball.ApplyForce(_gravityDown, _ball.GetPosition());				}										*/				//if off screen, reposition (just for testing)				if (auto && (by < 0 || by > _screenHeight)) {					enterbutton(1);					enterbutton(0);				}			}			_world.Step(1/Box2DUtils.P2M,10,10);   			//_world.ClearForces();			if(debugMode) {				_world.DrawDebugData();				if (!_container.contains(_debugContainer)) _container.addChild(_debugContainer);				if (_container.contains(leftControlSprite)) _container.removeChild(leftControlSprite);				if (_container.contains(rightControlSprite)) _container.removeChild(rightControlSprite);				if (_container.contains(ballSprite)) _container.removeChild(ballSprite);			} else {				for (var currentBody:b2Body = _world.GetBodyList(); currentBody != null; currentBody=currentBody.GetNext()) {					if(currentBody.GetUserData()){						//for (var item in currentBody.GetUserData()) trace(item)						var userData = currentBody.GetUserData()						if(userData.name && !debugMode){							switch (userData.name) {								case "ball" :									//trace(currentBody.GetPosition().x);									ballSprite.rotation = currentBody.GetAngle() * (180 / Math.PI);									ballSprite.x = currentBody.GetPosition().x * Box2DUtils.P2M;									ballSprite.y = currentBody.GetPosition().y * Box2DUtils.P2M;									break;								case "left" :									leftControlSprite.rotation = currentBody.GetAngle() * (180 / Math.PI);									break;								case "right" :									rightControlSprite.rotation = currentBody.GetAngle() * (180 / Math.PI);									break;							}						}					}				}				if (_container.contains(_debugContainer)) _container.removeChild(_debugContainer);				if (!_container.contains(leftControlSprite)) _container.addChild(leftControlSprite);				if (!_container.contains(rightControlSprite)) _container.addChild(rightControlSprite);				if (!_container.contains(ballSprite)) _container.addChild(ballSprite);			}									}				protected function myOnKeyUp(event:KeyboardEvent):void {			switch (event.keyCode) {				case 13:					//ENTER is down					enterbutton(0);					break;				case 39:					//RIGHT KEY is up					rightbutton(0);					break;				case 37:					//LEFT Key is up					leftbutton(0);					break;			}		}				protected function myOnKeyDown(event:KeyboardEvent):void {			switch (event.keyCode) {				case 72:					//H is down					showhide(1);					break;				case 13:					//ENTER is down					enterbutton(1);					break;				case 39:					//RIGHT KEY is down					rightbutton(1);					break;				case 37:					//LEFT Key is down					leftbutton(1);					break;			}					}				public function showhide(val:uint):void {			if(val==1) {				debugMode = !debugMode;			}				}				public function setAuto(val:uint):void {			if(val==1) {				auto = true;			} else {				auto = false;			}		}				public function setControlColorRed(val:uint):void {			var my_color:ColorTransform = new ColorTransform();			my_color.alphaMultiplier = 1;			my_color.redOffset = myRedOffset = val; 			my_color.greenOffset = myGreenOffset;			my_color.blueOffset = myBlueOffset;			leftControlSprite._ctrl.transform.colorTransform = my_color;			rightControlSprite._ctrl.transform.colorTransform = my_color;		}				public function setControlColorGreen(val:uint):void {			var my_color:ColorTransform = new ColorTransform();			my_color.alphaMultiplier = 1;			my_color.redOffset = myRedOffset; 			my_color.greenOffset = myGreenOffset = val;			my_color.blueOffset = myBlueOffset;			leftControlSprite._ctrl.transform.colorTransform = my_color;			rightControlSprite._ctrl.transform.colorTransform = my_color;		}				public function setControlColorBlue(val:uint):void {			var my_color:ColorTransform = new ColorTransform();			my_color.alphaMultiplier = 1;			my_color.redOffset = myRedOffset; 			my_color.greenOffset = myGreenOffset;			my_color.blueOffset = myBlueOffset = val;			leftControlSprite._ctrl.transform.colorTransform = my_color;			rightControlSprite._ctrl.transform.colorTransform = my_color;		}				public function setBallColorRed(val:uint):void {			var my_color:ColorTransform = new ColorTransform();			my_color.alphaMultiplier = 1;			my_color.redOffset = myBallRedOffset = val; 			my_color.greenOffset = myBallGreenOffset;			my_color.blueOffset = myBallBlueOffset;			ballSprite.transform.colorTransform = my_color;		}				public function setBallColorGreen(val:uint):void {			var my_color:ColorTransform = new ColorTransform();			my_color.alphaMultiplier = 1;			my_color.redOffset = myBallRedOffset; 			my_color.greenOffset = myBallGreenOffset = val;			my_color.blueOffset = myBallBlueOffset;			ballSprite.transform.colorTransform = my_color;		}				public function setBallColorBlue(val:uint):void {			var my_color:ColorTransform = new ColorTransform();			my_color.alphaMultiplier = 1;			my_color.redOffset = myBallRedOffset; 			my_color.greenOffset = myBallGreenOffset;			my_color.blueOffset = myBallBlueOffset = val;			ballSprite.transform.colorTransform = my_color;		}				public function setRestitutionCircle(val:uint):void {			restitutionCircle = val*.2;			trace(restitutionCircle)			var _ballFixture2:b2Fixture = _ball.GetFixtureList();			_ballFixture2.SetRestitution(restitutionCircle);					}				public function setRestitutionMap(val:uint):void {			restitutionMap = val;			trace(restitutionMap)			var _mapFixture2:b2Fixture = sep.body.GetFixtureList();			_mapFixture2.SetRestitution(restitutionMap);					}				public function setRestitutionControls(val:uint):void {			restitutionControl = val*.2;			trace(restitutionControl)			var _mapFixture2:b2Fixture = leftControl._flipper.GetFixtureList();			_mapFixture2.SetRestitution(restitutionControl);						_mapFixture2 = rightControl._flipper.GetFixtureList();			_mapFixture2.SetRestitution(restitutionControl);					}				public function enterbutton(val:uint):void {			if (enterstatus != val) {				enterstatus = val;				var stocazzo = 1;				if (val) {					_world.ClearForces();					_ball.SetPosition(Box2DUtils.P2MVector(((_screenWidth/2)+(ballStartPosition[0]/stocazzo)-(_ballRadius*3)), ((_screenHeight/2)+(ballStartPosition[1]/stocazzo)-(_ballRadius*3))));					_ball.SetLinearVelocity(Box2DUtils.P2MVector(0,0));				} else {					_ball.SetLinearVelocity(Box2DUtils.P2MVector(0,10000));					_ball.ApplyForce(_gravityDown, _ball.GetPosition());				}			}		}		public function rightbutton(val:uint):void {			if (rightstatus != val) {				trace(val);				rightstatus = val;				if (val) {					_controls[1].activate();				} else {					_controls[1].deActivate();				}			}		}		public function leftbutton(val:uint):void {			if (leftstatus != val) {				trace(val);				leftstatus = val;				if (val) {					_controls[0].activate();				} else {					_controls[0].deActivate();				}			}		}	}}