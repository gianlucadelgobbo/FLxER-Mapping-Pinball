package{	public class Block	{				import Box2D.Collision.Shapes.b2CircleShape;		import Box2D.Collision.Shapes.b2PolygonShape;		import Box2D.Common.Math.b2Vec2;		import Box2D.Dynamics.Joints.b2RevoluteJoint;		import Box2D.Dynamics.Joints.b2RevoluteJointDef;		import Box2D.Dynamics.b2Body;		import Box2D.Dynamics.b2BodyDef;		import Box2D.Dynamics.b2FixtureDef;		import Box2D.Dynamics.b2World;				import flash.geom.Point;		import flash.geom.Rectangle;		import flash.xml.XMLNode;				public static const TYPE_TRIANGLE_BOTTOM:int = 0;		public static const TYPE_TRIANGLE_TOP:int = 1;		public static const TYPE_CIRCLE:int = 2;		public static const TYPE_SQUARE:int = 3;		public static const SVG_FREE_SHAPE:int = 4;				public var touchLocation:Rectangle;		public var selected:Boolean = false;				private var _world:b2World;		private var _type:int;		private var _position:Point;		private var _body:b2Body;		private var _width:int = 32;				public function Block(world:b2World, x:Number, y:Number, xmlMap:XMLNode, type:int) {			_world = world;			_type = type;			_position = new Point (x, y);						//touchLocation = new Rectangle(x - _width *0.5, y - _width *0.5, _width, _width);						drawBlock(xmlMap);		}				private function drawBlock (xmlMap):void {						var location:b2Vec2 = Box2DUtils.P2MVector(_position.x, _position.y);						var bodyDef:b2BodyDef;			var bodyFixture:b2FixtureDef;			bodyFixture = new b2FixtureDef();						bodyDef = new b2BodyDef();			bodyDef.type = b2Body.b2_staticBody;			bodyDef.position.Set(location.x, location.y);						var vertices:Array = [];			var bodyShape:b2PolygonShape;						switch (_type) {								case TYPE_TRIANGLE_BOTTOM:								trace("TYPE_TRIANGLE_BOTTOM ");					vertices.push(Box2DUtils.P2MVector(0, - _width));			trace("TYPE_TRIANGLE_BOTTOM ");					vertices.push(Box2DUtils.P2MVector( _width, _width));			trace("TYPE_TRIANGLE_BOTTOM ");					vertices.push(Box2DUtils.P2MVector(- _width, _width));										bodyShape = b2PolygonShape.AsArray(vertices, vertices.length);								bodyFixture.shape = bodyShape;					bodyFixture.restitution = 1;										break;				case TYPE_TRIANGLE_TOP:										vertices.push(Box2DUtils.P2MVector(- _width*0.5, - _width*0.5));					vertices.push(Box2DUtils.P2MVector( _width*0.5, - _width*0.5));					vertices.push(Box2DUtils.P2MVector(0, _width*0.5));										bodyShape = b2PolygonShape.AsArray(vertices, vertices.length);								bodyFixture.shape = bodyShape;					bodyFixture.restitution = 1;					break;								case TYPE_CIRCLE:										var circle:b2CircleShape = new b2CircleShape(_width/Box2DUtils.P2M/2);					bodyFixture.shape = circle;					bodyFixture.density = 0;					bodyFixture.restitution = 1.5;					break;								case TYPE_SQUARE:										var boxShape:b2PolygonShape = new b2PolygonShape();					boxShape.SetAsBox (_width/Box2DUtils.P2M/2, _width/Box2DUtils.P2M/2);					bodyFixture.shape = boxShape;					bodyFixture.restitution = 0.5;					break;								case SVG_FREE_SHAPE:					var forma = xmlMap.attributes.d.substring(1).split("Q");					for (var b=0;b<forma.length-1;b++) {						forma[b] = forma[b].split(",");						//trace(forma[b][0]+" "+forma[b][1])				trace("SVG_FREE_SHAPE ");						vertices.push(new b2Vec2(forma[b][0]/300,forma[b][1]/300));						//wall.graphics.curveTo(forma[b][0],forma[b][1],(forma[b][2] ? forma[b][2] : forma[b][0]),(forma[b][3] ? forma[b][3] : forma[b][1]));					}					bodyShape = b2PolygonShape.AsArray(vertices, vertices.length);								bodyFixture.shape = bodyShape;					bodyFixture.restitution = 0;					break;			}						_body = _world.CreateBody(bodyDef);			_body.CreateFixture(bodyFixture);					}				/*		public function moveTo (x:Number):void {			if (x < _width ) {				selected = false;				return;							}			if (x > 270) {				selected = false;				return;			}						var pos:b2Vec2 = _body.GetPosition();			pos.x = x/Box2DUtils.P2M;			_body.SetPosition(pos);			touchLocation.x = x - _width *0.5;					}		private var _speed:int = 1;		public function update ():void {			var pos:b2Vec2 = _body.GetPosition();			pos.x += _speed * 2/Box2DUtils.P2M;			if (pos.x > 270/Box2DUtils.P2M) {				_speed = -1;			} else if (pos.x < _width/Box2DUtils.P2M) {				_speed = 1;			}			_body.SetPosition(pos);						touchLocation.x = pos.x * Box2DUtils.P2M - _width *0.5;		}		*/					}}